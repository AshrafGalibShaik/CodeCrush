{"instruction": "Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice.", "input": "nums = [2, 7, 11, 15], target = 9", "output": "def twoSum(nums, target):\n    hash_map = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in hash_map:\n            return [hash_map[complement], i]\n        hash_map[num] = i\n    return []\n# Time Complexity: O(n), Space Complexity: O(n)"}
{"instruction": "Reverse a singly linked list.", "input": "head = [1,2,3,4,5]", "output": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef reverseList(head):\n    prev = None\n    current = head\n    while current:\n        next_temp = current.next\n        current.next = prev\n        prev = current\n        current = next_temp\n    return prev\n# Time Complexity: O(n), Space Complexity: O(1)"}
{"instruction": "Given a string containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.", "input": "s = \"()[]{}\"", "output": "def isValid(s):\n    stack = []\n    brackets = {')': '(', '}': '{', ']': '['}\n    for char in s:\n        if char in brackets.values():\n            stack.append(char)\n        elif char in brackets:\n            if not stack or stack.pop() != brackets[char]:\n                return False\n    return len(stack) == 0\n# Time Complexity: O(n), Space Complexity: O(n)"}
{"instruction": "Merge two sorted linked lists and return it as a new sorted list.", "input": "l1 = [1,2,4], l2 = [1,3,4]", "output": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef mergeTwoLists(l1, l2):\n    dummy = ListNode(0)\n    current = dummy\n    while l1 and l2:\n        if l1.val <= l2.val:\n            current.next = l1\n            l1 = l1.next\n        else:\n            current.next = l2\n            l2 = l2.next\n        current = current.next\n    current.next = l1 if l1 else l2\n    return dummy.next\n# Time Complexity: O(n+m), Space Complexity: O(1)"}
{"instruction": "Given an array of integers, find the maximum subarray sum.", "input": "nums = [-2,1,-3,4,-1,2,1,-5,4]", "output": "def maxSubArray(nums):\n    max_sum = nums[0]\n    current_sum = nums[0]\n    for num in nums[1:]:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    return max_sum\n# Time Complexity: O(n), Space Complexity: O(1)"}
{"instruction": "Implement a stack using two queues.", "input": "", "output": "from collections import deque\n\nclass MyStack:\n    def __init__(self):\n        self.q1 = deque()\n        self.q2 = deque()\n\n    def push(self, x: int) -> None:\n        self.q2.append(x)\n        while self.q1:\n            self.q2.append(self.q1.popleft())\n        self.q1, self.q2 = self.q2, self.q1\n\n    def pop(self) -> int:\n        return self.q1.popleft()\n\n    def top(self) -> int:\n        return self.q1[0]\n\n    def empty(self) -> bool:\n        return len(self.q1) == 0\n# Time Complexity: push O(n), pop O(1), top O(1), empty O(1); Space Complexity: O(n)"}
{"instruction": "Find the median of two sorted arrays.", "input": "nums1 = [1,3], nums2 = [2]", "output": "def findMedianSortedArrays(nums1, nums2):\n    if len(nums1) > len(nums2):\n        nums1, nums2 = nums2, nums1\n    x, y = len(nums1), len(nums2)\n    start, end = 0, x\n    while start <= end:\n        partition_x = (start + end) // 2\n        partition_y = (x + y + 1) // 2 - partition_x\n        max_left_x = float('-inf') if partition_x == 0 else nums1[partition_x-1]\n        min_right_x = float('inf') if partition_x == x else nums1[partition_x]\n        max_left_y = float('-inf') if partition_y == 0 else nums2[partition_y-1]\n        min_right_y = float('inf') if partition_y == y else nums2[partition_y]\n        if max_left_x <= min_right_y and max_left_y <= min_right_x:\n            if (x + y) % 2 == 0:\n                return (max(max_left_x, max_left_y) + min(min_right_x, min_right_y)) / 2\n            return max(max_left_x, max_left_y)\n        elif max_left_x > min_right_y:\n            end = partition_x - 1\n        else:\n            start = partition_x + 1\n# Time Complexity: O(log(min(m,n))), Space Complexity: O(1)"}
{"instruction": "Implement a binary search tree with insert and search operations.", "input": "", "output": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass BST:\n    def __init__(self):\n        self.root = None\n\n    def insert(self, val):\n        if not self.root:\n            self.root = TreeNode(val)\n        else:\n            self._insert_recursive(self.root, val)\n\n    def _insert_recursive(self, node, val):\n        if val < node.val:\n            if node.left is None:\n                node.left = TreeNode(val)\n            else:\n                self._insert_recursive(node.left, val)\n        else:\n            if node.right is None:\n                node.right = TreeNode(val)\n            else:\n                self._insert_recursive(node.right, val)\n\n    def search(self, val):\n        return self._search_recursive(self.root, val)\n\n    def _search_recursive(self, node, val):\n        if not node or node.val == val:\n            return node\n        if val < node.val:\n            return self._search_recursive(node.left, val)\n        return self._search_recursive(node.right, val)\n# Time Complexity: O(h) for insert/search (h is tree height), Space Complexity: O(h)"}
{"instruction": "Given a string, find the length of the longest substring without repeating characters.", "input": "s = \"abcabcbb\"", "output": "def lengthOfLongestSubstring(s):\n    seen = {}\n    max_length = 0\n    start = 0\n    for end in range(len(s)):\n        if s[end] in seen and seen[s[end]] >= start:\n            start = seen[s[end]] + 1\n        else:\n            max_length = max(max_length, end - start + 1)\n        seen[s[end]] = end\n    return max_length\n# Time Complexity: O(n), Space Complexity: O(min(m,n)) where m is charset size"}
{"instruction": "Implement Dijkstra's algorithm to find the shortest path in a weighted graph.", "input": "graph = [[0,4,0,0,8],[4,0,8,0,0],[0,8,0,7,0],[0,0,7,0,9],[8,0,0,9,0]], start = 0", "output": "from heapq import heappush, heappop\n\ndef dijkstra(graph, start):\n    n = len(graph)\n    dist = [float('inf')] * n\n    dist[start] = 0\n    pq = [(0, start)]\n    while pq:\n        d, u = heappop(pq)\n        if d > dist[u]:\n            continue\n        for v in range(n):\n            if graph[u][v] > 0 and dist[v] > dist[u] + graph[u][v]:\n                dist[v] = dist[u] + graph[u][v]\n                heappush(pq, (dist[v], v))\n    return dist\n# Time Complexity: O(V^2) or O(E + V log V) with heap, Space Complexity: O(V)"}
{"instruction": "Given a string s, find the longest palindromic substring in s.", "input": "s = \"babad\"", "output": "def longestPalindrome(s):\n    n = len(s)\n    start = 0\n    max_length = 1\n    dp = [[False] * n for _ in range(n)]\n    for i in range(n):\n        dp[i][i] = True\n    for length in range(2, n + 1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n            if s[i] == s[j] and (length == 2 or dp[i + 1][j - 1]):\n                dp[i][j] = True\n                if length > max_length:\n                    max_length = length\n                    start = i\n    return s[start:start + max_length]\n# Time Complexity: O(n^2), Space Complexity: O(n^2)"}
{"instruction": "Implement a function to solve the N-Queens problem.", "input": "n = 4", "output": "def solveNQueens(n):\n    def create_board(positions):\n        board = [['.' for _ in range(n)] for _ in range(n)]\n        for row, col in enumerate(positions):\n            board[row][col] = 'Q'\n        return [' '.join(row) for row in board]\n\n    def is_safe(row, col, queens):\n        for prev_row, prev_col in enumerate(queens[:row]):\n            if prev_col == col or prev_row - prev_col == row - col or prev_row + prev_col == row + col:\n                return False\n        return True\n\n    def solve(row, queens, results):\n        if row == n:\n            results.append(create_board(queens))\n            return\n        for col in range(n):\n            if is_safe(row, col, queens):\n                queens[row] = col\n                solve(row + 1, queens, results)\n                queens[row] = 0\n\n    results = []\n    queens = [0] * n\n    solve(0, queens, results)\n    return results\n# Time Complexity: O(n!), Space Complexity: O(n)"}
{"instruction": "Given an array of intervals, merge all overlapping intervals.", "input": "intervals = [[1,3],[2,6],[8,10],[15,18]]", "output": "def merge(intervals):\n    if not intervals:\n        return []\n    intervals.sort(key=lambda x: x[0])\n    merged = [intervals[0]]\n    for current in intervals[1:]:\n        if current[0] <= merged[-1][1]:\n            merged[-1][1] = max(merged[-1][1], current[1])\n        else:\n            merged.append(current)\n    return merged\n# Time Complexity: O(n log n), Space Complexity: O(n)"}
{"instruction": "Implement a function to find the lowest common ancestor of two nodes in a binary tree.", "input": "root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1", "output": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef lowestCommonAncestor(root, p, q):\n    if not root or root == p or root == q:\n        return root\n    left = lowestCommonAncestor(root.left, p, q)\n    right = lowestCommonAncestor(root.right, p, q)\n    if left and right:\n        return root\n    return left if left else right\n# Time Complexity: O(n), Space Complexity: O(h) where h is tree height"}
{"instruction": "Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.", "input": "nums = [1,3,5,6], target = 5", "output": "def searchInsert(nums, target):\n    left, right = 0, len(nums) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return left\n# Time Complexity: O(log n), Space Complexity: O(1)"}
{"instruction": "Implement a trie (prefix tree) with insert, search, and startsWith methods.", "input": "", "output": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.is_end = True\n\n    def search(self, word):\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return node.is_end\n\n    def startsWith(self, prefix):\n        node = self.root\n        for char in prefix:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return True\n# Time Complexity: O(m) for insert/search/startsWith (m is word length), Space Complexity: O(m)"}
{"instruction": "Given a set of non-overlapping intervals and a new interval, insert the new interval into the intervals (merge if necessary).", "input": "intervals = [[1,3],[6,9]], newInterval = [2,5]", "output": "def insert(intervals, newInterval):\n    result = []\n    i = 0\n    n = len(intervals)\n    while i < n and intervals[i][1] < newInterval[0]:\n        result.append(intervals[i])\n        i += 1\n    while i < n and intervals[i][0] <= newInterval[1]:\n        newInterval[0] = min(newInterval[0], intervals[i][0])\n        newInterval[1] = max(newInterval[1], intervals[i][1])\n        i += 1\n    result.append(newInterval)\n    while i < n:\n        result.append(intervals[i])\n        i += 1\n    return result\n# Time Complexity: O(n), Space Complexity: O(n)"}
{"instruction": "Implement a function to find the kth smallest element in a binary search tree.", "input": "root = [3,1,4,null,2], k = 1", "output": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef kthSmallest(root, k):\n    def inorder(node, count):\n        if not node:\n            return None, count\n        left, count = inorder(node.left, count)\n        if left is not None:\n            return left, count\n        count += 1\n        if count == k:\n            return node.val, count\n        return inorder(node.right, count)\n    result, _ = inorder(root, 0)\n    return result\n# Time Complexity: O(h + k) where h is tree height, Space Complexity: O(h)"}
{"instruction": "Given an array of integers, return the length of the longest increasing subsequence.", "input": "nums = [10,9,2,5,3,7,101,18]", "output": "def lengthOfLIS(nums):\n    if not nums:\n        return 0\n    dp = [1] * len(nums)\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n# Time Complexity: O(n^2), Space Complexity: O(n)"}
{"instruction": "Implement a min heap data structure with push, pop, and getMin operations.", "input": "", "output": "class MinHeap:\n    def __init__(self):\n        self.heap = []\n\n    def push(self, val):\n        self.heap.append(val)\n        self._sift_up(len(self.heap) - 1)\n\n    def pop(self):\n        if not self.heap:\n            return None\n        if len(self.heap) == 1:\n            return self.heap.pop()\n        root = self.heap[0]\n        self.heap[0] = self.heap.pop()\n        self._sift_down(0)\n        return root\n\n    def getMin(self):\n        return self.heap[0] if self.heap else None\n\n    def _sift_up(self, index):\n        parent = (index - 1) // 2\n        if index > 0 and self.heap[index] < self.heap[parent]:\n            self.heap[index], self.heap[parent] = self.heap[parent], self.heap[index]\n            self._sift_up(parent)\n\n    def _sift_down(self, index):\n        min_index = index\n        left = 2 * index + 1\n        right = 2 * index + 2\n        if left < len(self.heap) and self.heap[left] < self.heap[min_index]:\n            min_index = left\n        if right < len(self.heap) and self.heap[right] < self.heap[min_index]:\n            min_index = right\n        if min_index != index:\n            self.heap[index], self.heap[min_index] = self.heap[min_index], self.heap[index]\n            self._sift_down(min_index)\n# Time Complexity: O(log n) for push/pop, O(1) for getMin, Space Complexity: O(n)"}